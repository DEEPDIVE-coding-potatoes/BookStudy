# Chapter1. 데이터 타입

## 1️⃣ 데이터 타입 종류

- **기본형**
    
    숫자(Number)
    문자열(String)
    Boolean
    null
    undefined
    Symbol(ES6 추가)
    
- **참조형(객체)**
    
    객체(Object)
    배열(Array)
    함수(Function)
    날짜(Date)
    정규식(RegExp)
    Map(ES6 추가)
    Set(ES6 추가)
    WeakMap(ES6 추가)
    WeakSet(ES6 추가)
    

### 차이점

- 일반적으로 기본형과 참조형의 차이는 
할당시 값이 복제되느냐 또는 주소값이 복제 되느냐의 차이가 있는것으로 알고있지만, **사실은 둘다 복제를 하고있음. 
다만 기본형은 값이 담긴 주소값을 복제하는 한편, 
참조형은 주소값들이 묶음을 가리키는 주소값을 복제한다는 점이 다름.**

---

## 2️⃣ 데이터 타입 배경지식

- 식별자는 데이터를 식별하는데 사용 하는 이름*(=변수명)*
- 변수는 변할수 있는 무언가*(=데이터)*
- **즉 변수는 변경 가능한 데이터를 담을수 있는 공간으로 정의 할수 있음.**

---

## 3️⃣ 변수 선언과 데이터 할당

### 1. 변수 선언

- 기본적인 변수 선언
*(식별자 age 라는 이름을 가진 **변할 수 있는 데이터를 만든다**)*
- 컴퓨터가 메모리에서 비어 있는 공간을 할당 하여, 
1002번이라는 임의의 공간에 age라는 식별자 이름을 가진 변수를
지정함.

```jsx
var age;
```

| 주소 | 1001 | 1002 | 1003 |
| --- | --- | --- | --- |
| 데이터 |  | 이름:age
값:'' |  |

### 2.데이터 할당

- **데이터를 저장하기 위해 별도의 메모리공간을 확보하여 할당한 값을 저장하고 그 주소값을 변수 영역에 저장하는 방식으로 이루어짐.**
    
    ```jsx
    var age = 30;
    ```
    
    - 주소영역
        
        
        | 주소 | ... | 1002 | 1003 |
        | --- | --- | --- | --- |
        | 데이터 |  | 이름:age
        값:'@5003' |  |
    - 데이터영역
        
        
        | 주소 |  | 5002 | 5003 |
        | --- | --- | --- | --- |
        | 데이터 |  |  | 30 |

> **데이터 할당 과정**
> 
> 1. 변수 영역에 빈공간을 확보(@1002)
> 2. 확보된 공간(@1002)에 식별자 `age`로 지정.
> 3. 데이터 영역의 빈공간(@5003)에 숫자 30을 지정.
> 4. 변수 영역에서 `age`식별자를 검색(@1002).
> 5. 앞서 저장한 숫자의 주소(@5003)를 @1002의 공간에 대입.

- 변수 변경의 과정
    
    ```jsx
    var age = 30;
    age = 100;
    ```
    
- 주소영역
    
    
    | 주소 | ... | 1002 | 1003 |
    | --- | --- | --- | --- |
    | 데이터 |  | 이름:age
    값:'@5002 -> @5003' |  |
- 데이터 영역
    
    
    | 주소 |  | 5002 | 5003 |
    | --- | --- | --- | --- |
    | 데이터 |  | 30 | 100 |
    
    > **데이터 변경 과정**
    > 
    > 1. 데이터 영역에 빈공간 확보(@5002)
    > 2. @5003 공간에 숫자 100을 저장
    > *(이때 문자열을 변경한다고하면, 문자열의 값을 제거해도 무조건 새공간에 데이터를 저장함)*
    > 3. @5003 영역은 age 식별자를 가진 변수 영역을 탐색.
    > 4. 변수영역에서 해당 식별자를 찾았다면,
    > 주소값을 **@5002에서 @5003**로 변경.

---

## 4️⃣ 기본형 데이터와 참조형 데이터

### 4-1. 불변값

- 변수와 상수의 구분하는 것은 **변경 가능성임.**
*(변경가능성의 대상은 변수 영역에 메모리이며, 한번 할당된 변수공간에 다른 데이터를 재할당 할 수 있는지 여부가 관건)*
    
    > **불변값 ≠ 상수** 둘은 다른 개념. 
    불변성 여부를 구별할때 변경 가능성의 대상은 
    데이터 영역 메모리이다.
    > 
- 한번 생성된 데이터 영역은 값을 아무리 변경 하더라도 
기존에 저장된 데이터 영역은 변경 되지 않고
기존 데이터 영역에 값이 있으면 재활용하고
없으면 새로운 영역에 만든 다음 식별자에서 주소값을 변경하는 식
으로 저장을 함.
*( 기본형 데이터 타입인 숫자, 문자열 ,boolean, null, undefined, symbol은 모두 불변값임. )*

### 4-2. 가변값

### 1) 참조형의 데이터 할당

```jsx
var obj1 ={
  a: 1,
  b: 'bbb'
}
```

- 변수영역

| 주소 | ... | 1002 | 1003 | 004 |
| --- | --- | --- | --- | --- |
| 데이터 |  | 이름:obj1
값:'@5001' |  |  |
- 데이터 영역

| 주소 | 5001 | 5002 | 5003 | 5004 |
| --- | --- | --- | --- | --- |
| 데이터 | @7103~ |  | 1 | 'bbb' |
- 객체 @5002의 변수 영역

| 주소 | 7103 | 7104 | 7105 | 106 |
| --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값 : @5003 | 이름:b
값: @5004 |  |  |
|  |  |  |  |  |

> **참조형 데이터 할당 과정**
> 
> 1. 변수영역에 빈 공간(@1002)을 확보.
> 2. 프로퍼티를 저장하기 위한 별도의 데이터 영역에 빈 공간(@5001)을 확보하여 그 영역의 주소(@7103~ ?)를 저장.
> 3. @7103 및 @7104에 각각 프로퍼티 이름을 지정.
> 4. 데이터 영역에서 값 1을 검색하여 임의로 @5003에 저장 하여,
> 이 주소값을 @7103 영역의 값으로 저장.
> 값 ‘bbb’도 마찬가지로 검색하여 임의로 @5004로 저장 후, 
> 이 주소값을 @7104 영역의 값으로 저장.

### 2) 참조형 데이터의 프로퍼티 재할당

```jsx
var obj1 ={
  a: 1,
  b: 'bbb'
}
obj1.a = 2;
```

- 변수영역 (불변)

| 주소 | ... | 1002 | 1003 | 1004 | 1005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  | 이름:obj1
값:'@5001' |  |  |  |
- 데이터 영역

| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 | @7103~ |  | 1 | 'bbb' | 2 |
- 객체 @5002의 변수 영역

| 주소 | 7103 | 7104 | 7105 | 7106 | 7107 |
| --- | --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값 : @5005 | 이름:b
값: @5004 |  |  |  |
|  |  |  |  |  |  |

> ⭐ **변수영역에 주소값은 불변.**
> 
> 
> 데이터 영역에 2이라는 값이 있다면 해당 영역에 재활용 한다.
> 그렇지 않으면 새로운 영역을 할당하여 2을 넣고, 
> 해당 주소값을 @7103의 변수영역에 저장함.
> 

**즉, 참조형은 변수안 프로퍼티의 값이 바뀌어도 
변수영역에서 식별자 obj1의 주솟값은 변경이 되지않음.**

### 3) 중첩된 참조형 데이터(객체)의 프로퍼티 할당(*객체안에 객체* )

```jsx
var obj={
  x: 3,
  arr:[3, 4, 5]
}
```

- 변수영역

| 주소 | 1001 | 1002 | 1003 | 1004 | 1005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  | 이름: obj
값:'@5001' |  |  |  |
- 데이터 영역

| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 | @7103~ | 3 | @8104~ | 4 | 5 |
- 객체 @5001의 변수 영역

| 주소 | 7103 | 7104 |
| --- | --- | --- |
| 데이터 | 이름: x
값: @5002 | 이름: arr
값: @5003 |
- 배열 @5003의 변수 영역

| 주소 | 8104 | 8105 | 8106 |
| --- | --- | --- | --- |
| 데이터 | 이름 : 0
값 : @5002 | 이름: 1
값: @5004 | 이름: 2
값: @5005 |

> **중첩된 참조형 데이터 할당 과정**
> 
> 1. 변수영역에 빈 공간(@1002)을 확보, 그 주소의 이름을 obj로 지정
> 2. 프로퍼티를 저장하기 위한 별도의 데이터 영역에 빈 공간(@5001)을 확보하여 그 영역의 주소(@7103~ ?)를 저장.
> 3. @7103, @7104 에 각각 프로퍼티이름(x, arr)을 지정.
> 4. 데이터 영역에서 3을 검색하여 임의로 @5002에 저장하고 이 주소값을 @7103 영역의 값으로 저장. 
> 5. @7104의 arr은 배열이 저장되기 떄문에, 이를 저장하기위한 별도의 변수영역을 추가.(@8104~)
> 6. 그 영역의 주소정보(@8104~)를 @5003에 저장한다음. @5003을 @7104에 저장함
> 7. 배열의 요소가 총 3개이므로 3개의 변수 공간을 확보하고 각각 인덱스를 부여함(0, 1, 2)
> 8. 데이터 영역에서 3을 검색해서 그 주소(@5002)를 @8104에 저장
> 9. 데이터 영역에 4가 없으므로 @5004에 저장하고, 이 주소를 @8105에 저장
> 10. 데이터 영역에 5가 없으므로 @5005에 저장하고, 이 주소를 @8106에 저장

### 4) 변수 복사

```jsx
var a = 10;
var b = a;

var obj1={
  c:'cccc',
  d:100
};
var obj2 = obj1;
```

- 변수영역

| 주소 | 1001 | 1002 | 1003 | 1004 |
| --- | --- | --- | --- | --- |
| 데이터 | 이름:a
값:'@5001' | 이름:b
값:'@5001' | 이름:obj1
값:'@5002' | 이름:obj2
값:'@5002' |
- 데이터 영역

| 주소 | 5001 | 5002 | 5003 | 5004 |
| --- | --- | --- | --- | --- |
| 데이터 | 10 | @7101~ | cccc | 100 |
- 객체 @5002의 변수 영역

| 주소 | 7101 | 7102 | 7103 | 7104 |
| --- | --- | --- | --- | --- |
| 데이터 | 이름:c
값: @5003 | 이름: d
값:@5004 |  |  |

> **주소 복사 과정(기본형)**
> 
> 1. 식별자 a를 @1001에 지정 
> 값 10이 데이터 영역에 없기때문에 @5001에 지정
> 식별자 a를 가진 변수영역을 찾아 해당 데이터영역 주소값을 넣음
> 2. 식별자 b를 @1002에 저장
> 값 10이 데이터 영역에 있기 때문에 해당 데이터영역 주소 값을(@5001) 저장

> **주소 복사 과정(참조형)**
> 
> 1. 식별자 obj1을 @1003에 저장
> 객체 안에 있는 값을 저장하기 위한 obj1 프로퍼티 별도의 변수영역 주소값을 데이터 영역에 지정(@5002)
> 2. @7101~7102 영역에 프로퍼티명 지정
> 해당 값이 없을때는 데이터 영역에 새로추가(@5003, 5004)
> 각 프로퍼티명을 가진 객체의 변수영역을 찾아 해당 데이터영역 주소값을 넣음
> 3. 식별자 obj2을 @1004에 저장
> 식별자 @obj1을 찾아 해당 변수영역 주소값을 넣음

- 기본형과 참조형의 복사과정은 동일하게 이루어 지나, 변수가 변경될때 과정에서 차이가 있음.

```jsx
var a = 10;
var b = a;
var obj1={ c:'cccc', d:100 };
var obj2 = obj1;

b=100;
obj2.d=50;
```

- 변수영역
    
    
    | 주소 | 1001 | 1002 | 1003 | 1004 |
    | --- | --- | --- | --- | --- |
    | 데이터 | 이름:a,값:'@5001' | 이름:b,
    값:'@5001 -> @5004' | 이름:obj1,값:'@5002' | 이름:obj2,값:'@5002' |
- 데이터 영역
    
    
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
    | --- | --- | --- | --- | --- | --- |
    | 데이터 | 10 | @7101~ | cccc | 100 | 50 |
- 객체 @5002의 변수 영역
    
    
    | 주소 | 7101 | 7102 | 7103 | 7104 |
    | --- | --- | --- | --- | --- |
    | 데이터 | 이름:c
    값: @5003 | 이름: d
    값:@5004 -> @5005 |  |  |
    
    > **기본형**
    > 
    > 1. 식별자 a를 @1001에 지정
    > 값 10이 데이터 영역에 없기때문에 @5001에 지정
    > 식별자 a를 가진 변수영역을 찾아 해당 데이터영역 주소값을 넣음(@5001)(@)
    > 2. 식별자 b를 @1002에 저장
    > 값 10이 데이터 영역에 있기 때문에 해당 데이터영역 주소 값을(@5001) 저장
    > 3. 데이터 100이 데이터 영역에 있으므로(@5004) 변수영역에 있는 식별자 b의 주소값을 해당 주소값으로 변경(@5001 → @5004)
    
    > **참조형**
    > 
    > 1. 식별자 obj1을 @1003에 저장
    > 객체 안에 있는 값을 저장하기 위해 obj1 프로퍼티의 별도의 변수영역 주소값을 데이터 영역에 지정(@5002)
    > 2. @7101~7102 영역에 프로퍼티명 지정
    > 해당 값이 없을때는 데이터 영역에 새로추가(@5003, 5004)
    > 각 프로퍼티명을 가진 객체의 변수영역을 찾아 해당 데이터영역 주소값을 넣음
    > 3. 식별자 obj2를 @1004에 저장
    > 식별자 @obj1을 찾아 해당 변수영역 주소값을 넣음(@5002)
    > 4. 데이터 영역에 50값을 담기위한 영역 추가(@5005)
    > 5. obj2의 변수영역(@7101~)에서 d가 변경되어 프로퍼티 d의 데이터 영역 주소값이 변경(@5004 → @5005)
    
    - 해당 과정의 결과 기본형은 변수영역의 주소값이 서로 달라졌지만, 
    참조형 데이터는 프로퍼티의 영역을 담고있는 주소값이 변경되지않았기 때문에, 
    obj2 객체의 d프로퍼티 값을 변경하면 → obj1 객체의 d프로퍼티 값도 같이 변경됨. 
    즉, 이 결과를 아래와 같은 코드로 표현이 가능.
    
    ```jsx
    a !== b
    obj1 === obj2
    ```
    
    - 책에선, 기본형은 값을 복사하고 참조형은 주소값을 복사한다 라고 설명하고있지만
    - → 어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사해야 하기 때문에
    *기본형은 주소값을 복사하는 과정이 1번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있음*

- 객체 전체를 변경했을 때
    
    ```jsx
    var a = 10;
    var b = a;
    var obj1 = { c:'cccc', d:100 };
    var obj2 = obj1;
    
    b = 100;
    obj2 = { c:'dddd', d:50};
    ```
    
- 변수영역
    
    
    | 주소 | 1001 | 1002 | 1003 | 1004 |
    | --- | --- | --- | --- | --- |
    | 데이터 | 이름:a,값:'@5001' | 이름:b
    값:'@5001 -> @5004' | 이름: obj1값:'@5002' | 이름: obj2
    값:'@5002->@5005' |
- 데이터 영역
    
    
    | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | 5007 |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    | 데이터 | 10 | @7101~ | cccc | 100 | @8101~? | dddd | 50 |
- 객체 @5002의 변수 영역
    
    
    | 주소 | 7101 | 7102 | 7103 | 7104 |
    | --- | --- | --- | --- | --- |
    | 데이터 | 이름:c
    값: @5003 | 이름: d
    값:@5004 |  |  |
- 객체 @5005의 변수 영역
    
    
    | 주소 | 8101 | 8102 | 8103 | 8104 |
    | --- | --- | --- | --- | --- |
    | 데이터 | 이름:c
    값: @5006 | 이름: d
    값:@5007 |  |  |
    
    > **기본형**
    > 
    > 1. 식별자 a를 @1001에 지정.
    > 값 10이 데이터 영역에 없기때문에 @5001에 지정
    > 식별자 a를 가진 변수영역을 찾아 해당 데이터영역 주소값을 넣음
    > 2. 식별자 b를 @1002에 저장
    > 값 10이 데이터 영역에 있기 때문에 해당 데이터영역 주소 값을(@5001) 저장.
    > 3. 데이터 100이 데이터 영역에(@5004) 있으므로 
    > 변수영역에 있는 식별자 b의 주소값을 해당 주소값으로 변경(@5001 → @5004)
    
    > **참조형**
    > 
    > 1. 식별자 obj1을 @1003에 저장
    > 객체 안에 있는 값을 저장하기 위한 obj1 프로퍼티의 별도의 변수영역 주소값을 
    > 데이터 영역에 지정(@5002)
    > 2. @7101~7102 영역에 프로퍼티명 지정
    > 해당 값이 없을때는 데이터 영역에 새로추가(@5003, 5004)
    > 각 프로퍼티명을 가진 객체의 변수영역을 찾아 해당 데이터영역 주소값을 넣음.
    > 3. 식별자 obj2을 @1004에 저장
    > 식별자 @obj1을 찾아 해당 변수영역 주소값을 넣음.
    > 4. 객체에 새로운값을 저장하기위한 obj2의 프로퍼티 별도 주소변수 영역값을 
    > 데이터에 지정(@5005)
    > 5. @8101~8102 영역에 프로퍼티명 지정
    > 해당 값이 없을때는 데이터 영역에 새로추가(@5006, 5007)
    > 각 프로퍼티명을 가진 객체의 변수영역을 찾아 해당 데이터영역 주소값을 넣음.
    > 6. 식별자 obj2의 기존 주소값을 새로 할당한 변수영역의 주소값으로 변경
    
    **🔹  참조형 데이터가 '가변값'인 경우는 데이터 자체(객체)변경이 아닌 객체 내부의 프로퍼티를 변경 할때만 성립.**
    

---

## 5️⃣ 불변 객체

### 1) 불변 객체를 만드는법

- **어떤 상황에서 불변객체가 필요한가?**
→ 값으로 전달받은 객체에 변경을 가하더라도 원본객체는 변하지 않아야 할 때

```jsx
var user1={
  name:'jaenam',
  gender:'male'
};

var changeName = function(user,newName){
	return{
      name:newName,
      gender:user.gender
    };
    
var user2 = changeName(user1,'Jung');

if(user1 !== user2){
  console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name,user2.name);//'Jaenam','Jung'
console.log(user1 === user2);//false
```

### 2) 얇은 복사 vs 깊은 복사

- **얇은 복사 :** 
**아래 단계의 값만 복사.** 
만약에 중첩된 객체가 있다면, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 
그 주소값만 복사함. 따라서 중첩된 객체의 주소값은 동일한 주소값이 되기 때문에 
참조형 변수의 가변성에 의해 원본이 변경되면 복사본의 값도 변경됨.

```jsx
function copyObject(target){
  var result={};
  for(var prop in target){
    result[prop]=target[prop];
  }
  return result;
}
var user={
  name:'Jaenam',
  urls:{
    portfolio:'http://github.com'
  }
};
var user2=copyObject(user);

user2.name = 'Jung'
console.log(user2.name === user.name);//false

user2.urls.portfolio='https://portfolio.com';
console.log(user2.urls.portfolio === user.urls.portfolio);//true
```

- **깊은복사 :**
**내부의 모든 값들(중첩된 객체까지)을 하나하나 전부 찾아서 복사**하는 방법.

```jsx
var copyObject=function(target){
  var result={};
  if(typeof target === 'object' && target !== null){
  	for(var prop in target){
      result[prop]=copyObject(target[prop]);
    }
  }else{
    result = target;
  }

  return result;
}
var user={
  name:'Jaenam',
  urls:{
    portfolio:'http://github.com'
  }
};
var user2=copyObject(user);

user2.name = 'Jung'
console.log(user2.name === user.name);//false

user2.urls.portfolio='https://portfolio.com';
console.log(user2.urls.portfolio === user.urls.portfolio);//false
```

- JSON.stringify(object)를 통해 간단하게 깊은 복사 가능.

---

## 6️⃣ undefined와 null

- 둘다 '없음'을 나타내는 값.
- **undefined**
    - 값을 대입하지않은 변수
    *(변수영역에 식별자는 있으나 값에 데이터영역 주소값이 들어가지않은 상태)*
    - 객체내부에서 존재하지않는 프로퍼티 접근시 return되는 값
    - return값이 없거나 호출되지않는 함수 실행결과
    - 길이는 있지만 값은 비어있는 배열에서는 
    값이 `[empty * 배열길이]` 로 나오는 경우가 있는데, 
    이때 배열객체를 가진 변수는 undefined 그 자체가 아닌 비어있는 요소를 가진 객체로 보는게 맞음
    - 값을 대입하지 않은 변수에 접근하고자 할 때, 자바스크립트 엔진이 반환해주는 값
- **null**
    - '비어있음'의 명시적 의미를 쓰고싶다면 null을 사용.
    - `typeof null` 을 로그로 찍으면 object가 나옴(JS 자체 버그임)
    정확한 확인을 위해서는 `===`(일치 연산자)를 통한 비교를 해야함
    
    ---
    
    ## 7️⃣ 정리 (자바스크립트 데이터 타입 요약)
    
    1.  **자바스크립트 데이터 타입은 크게 2가지**
    ✔️ 기본형(Primitive Type)
    ✔️ 참조형(Reference Type)
    2. **기본형 vs 참조형**
        
        
        | 구분 | 기본형 | 참조형 |
        | --- | --- | --- |
        | 특징 | 값 자체 저장 | 주소(참조값) 저장 |
        | 변경 가능 여부 | ❌ 불변값 | ✅ 가변값 |
        | 예시 | `Number`, `String`, `Boolean`, `null`, `undefined`, `Symbol` | `Object`, `Array`, `Function` |
    3. **변수와 식별자**
        
        ✔ 변수 : 변경 가능한 데이터가 담길 수 있는 공간
        
        ✔ 식별자 : 변수를 가리키는 이름
        
    4. **기본형과 참조형의 저장 방식**
        - 기본형 ****: 
        변수를 선언하면 *메모리에 식별자를 저장하고, 기본적으로 `undefined` 할당* → 이후 값을 저장할 별도 공간을 만들고 그 주소를 변수에 저장
        - 참조형 ****: 
        데이터를 저장할 별도의 변수 영역 확보 → 내부 프로퍼티들을 위한 변수도 따로 확보 → 각 프로퍼티를 별도 공간에 저장하고 주소로 연결
    5. **참조형을 불변값처럼 사용하려면?**
        
        ✔ 깊은 복사 (Deep Copy) → 내부 프로퍼티를 일일이 복사
        
        ✔ 라이브러리 활용 (`lodash.cloneDeep()` 등)
        
        ✔ 불변 객체 (Immutable Object) → 최근 JS에서 중요한 개념
        
    6. **‘없음’을 나타내는 값**
        
        
        | 값 | 의미 |
        | --- | --- |
        | `undefined` | 변수가 선언되었지만 값이 할당되지 않음 (자동 할당됨) |
        | `null` | 개발자가 명시적으로 ‘없음’을 표현하기 위해 할당 |
        
        🔹 **`undefined`를 명시적으로 할당하는 것은 지양하는 것이 좋음!**